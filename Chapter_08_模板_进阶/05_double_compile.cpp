/*
二次编译
- 编译器对函数模板都会进行两次编译
- 第一次编译发生在实例化函数模板之前（产生真正函数实体之前），只检查函数模板
  本身内部代码，检查基本词法是否正确：
  1. 函数模板内部出现的所有标识符是否均有声明
  2. 对于已知类型的调用要查看调用是否有效
  3. 对于未知类型的调用都认为合理
- 第二次编译发生在实例化函数模板之后（产生真正函数实体之后），
  结合所使用的类型实参，再次检查模板代码，查看所有调用是否真的均有效

*/
#include <iostream>

using namespace std;

class A
{
public:
    void func()
    {
        cout << "A::func()" << endl;
    }
};

template <class T>
void foo()
{
    // jklaqwij // 错误的标识符将在第一次编译时报错
    A a;
    a.func(); // 对已知类型的调用
    T t;
    t.qiojnkzx(); // 未知类型调用，在第一次编译时不会报错
    // t.qiojnk<zx>(); // 未知类型调用，但由于出现<>，会报错
}

int main()
{
    // foo<A>();  // 第二次编译会报错，没有成员qiojnkzx
    return 0;
}